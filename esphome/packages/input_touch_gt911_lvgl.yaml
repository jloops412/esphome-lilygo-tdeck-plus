touchscreen:
  - platform: gt911
    id: tdeck_touch
    display: tft
    address: 0x5D
    update_interval: 30ms
    touch_timeout: 50ms
    calibration:
      x_min: ${touch_x_min}
      x_max: ${touch_x_max}
      y_min: ${touch_y_min}
      y_max: ${touch_y_max}
    transform:
      swap_xy: true
      mirror_x: false
      mirror_y: true
    on_touch:
      then:
        - if:
            condition:
              lambda: "return id(wake_on_touch);"
            then:
              - script.execute: note_activity
        - lambda: |-
            id(touch_raw_x_last) = touch.x_raw;
            id(touch_raw_y_last) = touch.y_raw;
            id(touch_x_last) = touch.x;
            id(touch_y_last) = touch.y;
            id(touch_active) = true;
        - if:
            condition:
              lambda: "return id(touch_cal_mode);"
            then:
              - script.execute: lvgl_update_dynamic

    on_release:
      then:
        - if:
            condition:
              lambda: "return id(touch_cal_mode);"
            then:
              - lambda: |-
                  switch (id(touch_cal_step)) {
                    case 0:
                      id(cal9_raw_tl_x) = id(touch_raw_x_last);
                      id(cal9_raw_tl_y) = id(touch_raw_y_last);
                      break;
                    case 1:
                      id(cal9_raw_tc_x) = id(touch_raw_x_last);
                      id(cal9_raw_tc_y) = id(touch_raw_y_last);
                      break;
                    case 2:
                      id(cal9_raw_tr_x) = id(touch_raw_x_last);
                      id(cal9_raw_tr_y) = id(touch_raw_y_last);
                      break;
                    case 3:
                      id(cal9_raw_ml_x) = id(touch_raw_x_last);
                      id(cal9_raw_ml_y) = id(touch_raw_y_last);
                      break;
                    case 4:
                      id(cal9_raw_mc_x) = id(touch_raw_x_last);
                      id(cal9_raw_mc_y) = id(touch_raw_y_last);
                      break;
                    case 5:
                      id(cal9_raw_mr_x) = id(touch_raw_x_last);
                      id(cal9_raw_mr_y) = id(touch_raw_y_last);
                      break;
                    case 6:
                      id(cal9_raw_bl_x) = id(touch_raw_x_last);
                      id(cal9_raw_bl_y) = id(touch_raw_y_last);
                      break;
                    case 7:
                      id(cal9_raw_bc_x) = id(touch_raw_x_last);
                      id(cal9_raw_bc_y) = id(touch_raw_y_last);
                      break;
                    case 8:
                    default:
                      id(cal9_raw_br_x) = id(touch_raw_x_last);
                      id(cal9_raw_br_y) = id(touch_raw_y_last);
                      break;
                  }

                  if (id(touch_cal_step) >= 8) {
                    // 9-point fit reduced to 3 averaged columns/rows for better edge stability.
                    // Targets are intentionally near the usable edges, not bezel limits.
                    const double tx0 = 18.0, tx1 = 160.0, tx2 = 302.0;
                    const double ty0 = 34.0, ty1 = 120.0, ty2 = 206.0;

                    const double rx0 = ((double) id(cal9_raw_tl_x) + (double) id(cal9_raw_ml_x) + (double) id(cal9_raw_bl_x)) / 3.0;
                    const double rx1 = ((double) id(cal9_raw_tc_x) + (double) id(cal9_raw_mc_x) + (double) id(cal9_raw_bc_x)) / 3.0;
                    const double rx2 = ((double) id(cal9_raw_tr_x) + (double) id(cal9_raw_mr_x) + (double) id(cal9_raw_br_x)) / 3.0;
                    const double ry0 = ((double) id(cal9_raw_tl_y) + (double) id(cal9_raw_tc_y) + (double) id(cal9_raw_tr_y)) / 3.0;
                    const double ry1 = ((double) id(cal9_raw_ml_y) + (double) id(cal9_raw_mc_y) + (double) id(cal9_raw_mr_y)) / 3.0;
                    const double ry2 = ((double) id(cal9_raw_bl_y) + (double) id(cal9_raw_bc_y) + (double) id(cal9_raw_br_y)) / 3.0;

                    const double tx_mean = (tx0 + tx1 + tx2) / 3.0;
                    const double rx_mean = (rx0 + rx1 + rx2) / 3.0;
                    const double ty_mean = (ty0 + ty1 + ty2) / 3.0;
                    const double ry_mean = (ry0 + ry1 + ry2) / 3.0;

                    const double den_x =
                      (tx0 - tx_mean) * (tx0 - tx_mean) +
                      (tx1 - tx_mean) * (tx1 - tx_mean) +
                      (tx2 - tx_mean) * (tx2 - tx_mean);
                    const double den_y =
                      (ty0 - ty_mean) * (ty0 - ty_mean) +
                      (ty1 - ty_mean) * (ty1 - ty_mean) +
                      (ty2 - ty_mean) * (ty2 - ty_mean);

                    if ((den_x > -0.001 && den_x < 0.001) || (den_y > -0.001 && den_y < 0.001)) {
                      ESP_LOGW("touch_cal", "Rejected calibration: degenerate regression");
                      id(touch_cal_mode) = false;
                      id(touch_cal_step) = 0;
                      return;
                    }

                    const double bx =
                      ((tx0 - tx_mean) * (rx0 - rx_mean) +
                       (tx1 - tx_mean) * (rx1 - rx_mean) +
                       (tx2 - tx_mean) * (rx2 - rx_mean)) / den_x;
                    const double by =
                      ((ty0 - ty_mean) * (ry0 - ry_mean) +
                       (ty1 - ty_mean) * (ry1 - ry_mean) +
                       (ty2 - ty_mean) * (ry2 - ry_mean)) / den_y;

                    const double ax = rx_mean - (bx * tx_mean);
                    const double ay = ry_mean - (by * ty_mean);

                    int x_min = (int) (ax + (ax >= 0.0 ? 0.5 : -0.5));
                    int x_max = (int) ((ax + bx * 319.0) + ((ax + bx * 319.0) >= 0.0 ? 0.5 : -0.5));
                    int y_min = (int) (ay + (ay >= 0.0 ? 0.5 : -0.5));
                    int y_max = (int) ((ay + by * 239.0) + ((ay + by * 239.0) >= 0.0 ? 0.5 : -0.5));

                    if (x_min > x_max) {
                      int t = x_min;
                      x_min = x_max;
                      x_max = t;
                    }
                    if (y_min > y_max) {
                      int t = y_min;
                      y_min = y_max;
                      y_max = t;
                    }

                    if (x_min < 0) x_min = 0;
                    if (x_max > 4095) x_max = 4095;
                    if (y_min < 0) y_min = 0;
                    if (y_max > 4095) y_max = 4095;

                    if (x_max - x_min < 32 || y_max - y_min < 32) {
                      ESP_LOGW("touch_cal", "Rejected calibration: invalid span x=%d y=%d", x_max - x_min, y_max - y_min);
                    } else {
                      id(touch_cal_suggest_x_min) = x_min;
                      id(touch_cal_suggest_x_max) = x_max;
                      id(touch_cal_suggest_y_min) = y_min;
                      id(touch_cal_suggest_y_max) = y_max;
                      id(tdeck_touch).set_calibration(
                        id(touch_cal_suggest_x_min),
                        id(touch_cal_suggest_x_max),
                        id(touch_cal_suggest_y_min),
                        id(touch_cal_suggest_y_max)
                      );
                      ESP_LOGI("touch_cal", "Applied GT911 calibration x_min=%d x_max=%d y_min=%d y_max=%d (9-point edge fit)",
                               id(touch_cal_suggest_x_min),
                               id(touch_cal_suggest_x_max),
                               id(touch_cal_suggest_y_min),
                               id(touch_cal_suggest_y_max));
                    }

                    id(touch_cal_mode) = false;
                    id(touch_cal_step) = 0;
                  } else {
                    id(touch_cal_step) += 1;
                  }
              - if:
                  condition:
                    lambda: "return !id(touch_cal_mode);"
                  then:
                    - lvgl.page.show: theme_page
              - script.execute: lvgl_update_dynamic
        - lambda: |-
            id(touch_active) = false;
