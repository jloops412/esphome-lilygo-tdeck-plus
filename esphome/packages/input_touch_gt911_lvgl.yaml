touchscreen:
  - platform: gt911
    id: tdeck_touch
    display: tft
    address: 0x5D
    update_interval: 30ms
    touch_timeout: 50ms
    calibration:
      x_min: ${touch_x_min}
      x_max: ${touch_x_max}
      y_min: ${touch_y_min}
      y_max: ${touch_y_max}
    transform:
      swap_xy: true
      mirror_x: false
      mirror_y: true
    on_touch:
      then:
        - if:
            condition:
              lambda: "return id(wake_on_touch);"
            then:
              - script.execute: note_activity
        - lambda: |-
            id(touch_raw_x_last) = touch.x_raw;
            id(touch_raw_y_last) = touch.y_raw;
            id(touch_x_last) = touch.x;
            id(touch_y_last) = touch.y;
            id(touch_active) = true;
        - if:
            condition:
              lambda: "return id(touch_cal_mode);"
            then:
              - script.execute: lvgl_update_dynamic

    on_release:
      then:
        - if:
            condition:
              lambda: "return id(touch_cal_mode);"
            then:
              - lambda: |-
                  switch (id(touch_cal_step)) {
                    case 0:
                      id(cal9_raw_tl_x) = id(touch_raw_x_last);
                      id(cal9_raw_tl_y) = id(touch_raw_y_last);
                      break;
                    case 1:
                      id(cal9_raw_tc_x) = id(touch_raw_x_last);
                      id(cal9_raw_tc_y) = id(touch_raw_y_last);
                      break;
                    case 2:
                      id(cal9_raw_tr_x) = id(touch_raw_x_last);
                      id(cal9_raw_tr_y) = id(touch_raw_y_last);
                      break;
                    case 3:
                      id(cal9_raw_ml_x) = id(touch_raw_x_last);
                      id(cal9_raw_ml_y) = id(touch_raw_y_last);
                      break;
                    case 4:
                      id(cal9_raw_mc_x) = id(touch_raw_x_last);
                      id(cal9_raw_mc_y) = id(touch_raw_y_last);
                      break;
                    case 5:
                      id(cal9_raw_mr_x) = id(touch_raw_x_last);
                      id(cal9_raw_mr_y) = id(touch_raw_y_last);
                      break;
                    case 6:
                      id(cal9_raw_bl_x) = id(touch_raw_x_last);
                      id(cal9_raw_bl_y) = id(touch_raw_y_last);
                      break;
                    case 7:
                      id(cal9_raw_bc_x) = id(touch_raw_x_last);
                      id(cal9_raw_bc_y) = id(touch_raw_y_last);
                      break;
                    case 8:
                    default:
                      id(cal9_raw_br_x) = id(touch_raw_x_last);
                      id(cal9_raw_br_y) = id(touch_raw_y_last);
                      break;
                  }

                  if (id(touch_cal_step) >= 8) {
                    const double tx[9] = {20, 160, 300, 20, 160, 300, 20, 160, 300};
                    const double ty[9] = {36, 36, 36, 110, 110, 110, 184, 184, 184};
                    const double rx[9] = {
                      (double) id(cal9_raw_tl_x), (double) id(cal9_raw_tc_x), (double) id(cal9_raw_tr_x),
                      (double) id(cal9_raw_ml_x), (double) id(cal9_raw_mc_x), (double) id(cal9_raw_mr_x),
                      (double) id(cal9_raw_bl_x), (double) id(cal9_raw_bc_x), (double) id(cal9_raw_br_x)
                    };
                    const double ry[9] = {
                      (double) id(cal9_raw_tl_y), (double) id(cal9_raw_tc_y), (double) id(cal9_raw_tr_y),
                      (double) id(cal9_raw_ml_y), (double) id(cal9_raw_mc_y), (double) id(cal9_raw_mr_y),
                      (double) id(cal9_raw_bl_y), (double) id(cal9_raw_bc_y), (double) id(cal9_raw_br_y)
                    };

                    const double n = 9.0;
                    double sx = 0.0, sy = 0.0, sxx = 0.0, sxy = 0.0;
                    double tx_sum = 0.0, ty_sum = 0.0, tyy = 0.0, tyy_raw = 0.0;
                    for (int i = 0; i < 9; i++) {
                      sx += tx[i];
                      sy += rx[i];
                      sxx += tx[i] * tx[i];
                      sxy += tx[i] * rx[i];

                      tx_sum += ty[i];
                      ty_sum += ry[i];
                      tyy += ty[i] * ty[i];
                      tyy_raw += ty[i] * ry[i];
                    }

                    double den_x = n * sxx - sx * sx;
                    double den_y = n * tyy - tx_sum * tx_sum;
                    if ((den_x > -0.001 && den_x < 0.001) || (den_y > -0.001 && den_y < 0.001)) {
                      ESP_LOGW("touch_cal", "Rejected calibration: degenerate regression");
                      id(touch_cal_mode) = false;
                      id(touch_cal_step) = 0;
                      return;
                    }

                    double bx = (n * sxy - sx * sy) / den_x;
                    double ax = (sy - bx * sx) / n;
                    double by = (n * tyy_raw - tx_sum * ty_sum) / den_y;
                    double ay = (ty_sum - by * tx_sum) / n;

                    int x_min = (int) (ax + (ax >= 0.0 ? 0.5 : -0.5));
                    int x_max = (int) ((ax + bx * 319.0) + ((ax + bx * 319.0) >= 0.0 ? 0.5 : -0.5));
                    int y_min = (int) (ay + (ay >= 0.0 ? 0.5 : -0.5));
                    int y_max = (int) ((ay + by * 239.0) + ((ay + by * 239.0) >= 0.0 ? 0.5 : -0.5));

                    if (x_min > x_max) {
                      int t = x_min;
                      x_min = x_max;
                      x_max = t;
                    }
                    if (y_min > y_max) {
                      int t = y_min;
                      y_min = y_max;
                      y_max = t;
                    }

                    if (x_min < 0) x_min = 0;
                    if (x_max > 4095) x_max = 4095;
                    if (y_min < 0) y_min = 0;
                    if (y_max > 4095) y_max = 4095;

                    if (x_max - x_min < 32 || y_max - y_min < 32) {
                      ESP_LOGW("touch_cal", "Rejected calibration: invalid span x=%d y=%d", x_max - x_min, y_max - y_min);
                    } else {
                      id(touch_cal_suggest_x_min) = x_min;
                      id(touch_cal_suggest_x_max) = x_max;
                      id(touch_cal_suggest_y_min) = y_min;
                      id(touch_cal_suggest_y_max) = y_max;
                      id(tdeck_touch).set_calibration(
                        id(touch_cal_suggest_x_min),
                        id(touch_cal_suggest_x_max),
                        id(touch_cal_suggest_y_min),
                        id(touch_cal_suggest_y_max)
                      );
                      ESP_LOGI("touch_cal", "Applied GT911 calibration x_min=%d x_max=%d y_min=%d y_max=%d (regression)",
                               id(touch_cal_suggest_x_min),
                               id(touch_cal_suggest_x_max),
                               id(touch_cal_suggest_y_min),
                               id(touch_cal_suggest_y_max));
                    }

                    id(touch_cal_mode) = false;
                    id(touch_cal_step) = 0;
                  } else {
                    id(touch_cal_step) += 1;
                  }
              - script.execute: lvgl_update_dynamic
        - lambda: |-
            id(touch_active) = false;
