display:
  - platform: mipi_spi
    id: tft
    model: CUSTOM
    bus_mode: single
    cs_pin: 12
    dc_pin: 11
    dimensions:
      width: 320
      height: 240
      offset_width: 0
      offset_height: 0
    transform:
      swap_xy: true
      mirror_x: true
      mirror_y: false
    color_order: rgb
    invert_colors: false
    spi_mode: MODE0
    data_rate: 16MHz
    byte_order: big_endian
    draw_rounding: 2
    update_interval: 120ms
    init_sequence:
      - [0x13]
      - delay 120ms
      - delay 10ms
      - [0xB2, 0x0C, 0x0C, 0x00, 0x33, 0x33]
      - [0xB7, 0x75]
      - [0xBB, 0x1A]
      - [0xC0, 0x2C]
      - [0xC2, 0x01]
      - [0xC3, 0x13]
      - [0xC4, 0x20]
      - [0xC6, 0x0F]
      - [0xD0, 0xA4, 0xA1]
      - [0xE0, 0xD0, 0x0D, 0x14, 0x0D, 0x0D, 0x09, 0x38, 0x44, 0x4E, 0x3A, 0x17, 0x18, 0x2F, 0x30]
      - [0xE1, 0xD0, 0x09, 0x0F, 0x08, 0x07, 0x14, 0x37, 0x44, 0x4D, 0x38, 0x15, 0x16, 0x2C, 0x3E]
      - [0x2A, 0x00, 0x00, 0x00, 0xEF]
      - [0x2B, 0x00, 0x00, 0x01, 0x3F]
    lambda: |-
      auto light_name = [&](int idx) -> const char * {
        switch (idx) {
          case 0: return "Foyer";
          case 1: return "Vanity";
          case 2: return "Bedroom";
          case 3: return "Hall";
          case 4: return "Office";
          default: return "Upstairs";
        }
      };

      auto light_state_text = [&](int idx) -> const char * {
        switch (idx) {
          case 0: return id(foyer_state).has_state() ? id(foyer_state).state.c_str() : "-";
          case 1: return id(vanity_state).has_state() ? id(vanity_state).state.c_str() : "-";
          case 2: return id(bedroom_state).has_state() ? id(bedroom_state).state.c_str() : "-";
          case 3: return id(hall_state).has_state() ? id(hall_state).state.c_str() : "-";
          case 4: return id(office_state).has_state() ? id(office_state).state.c_str() : "-";
          default: return id(upstairs_state).has_state() ? id(upstairs_state).state.c_str() : "-";
        }
      };

      auto c_bg = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_bg_alt1);
        if (id(theme_index) == 2) return id(col_bg_alt2);
        return id(col_bg);
      };
      auto c_panel = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_panel_alt1);
        if (id(theme_index) == 2) return id(col_panel_alt2);
        return id(col_panel);
      };
      auto c_panel_sel = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_panel_sel_alt1);
        if (id(theme_index) == 2) return id(col_panel_sel_alt2);
        return id(col_panel_sel);
      };
      auto c_border = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_border_alt1);
        if (id(theme_index) == 2) return id(col_border_alt2);
        return id(col_border);
      };
      auto c_text = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_text_alt1);
        if (id(theme_index) == 2) return id(col_text_alt2);
        return id(col_text);
      };
      auto c_text_dim = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_text_dim_alt1);
        if (id(theme_index) == 2) return id(col_text_dim_alt2);
        return id(col_text_dim);
      };
      auto c_good = [&]() -> Color {
        if (id(theme_index) == 1) return id(col_good_alt1);
        if (id(theme_index) == 2) return id(col_good_alt2);
        return id(col_good);
      };

      auto draw_tile = [&](int x, int y, int w, int h, const char *label, bool selected, const char *sub) {
        it.filled_rectangle(x, y, w, h, selected ? c_panel_sel() : c_panel());
        it.rectangle(x, y, w, h, selected ? c_good() : c_border());
        it.printf(x + w / 2, y + 12, id(font_tile), c_text(), TextAlign::TOP_CENTER, "%s", label);
        if (sub != nullptr) {
          it.printf(x + w / 2, y + 38, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER, "%s", sub);
        }
      };

      auto draw_crosshair = [&](int x, int y, Color c) {
        it.circle(x, y, 14, c);
        it.circle(x, y, 7, c);
        it.line(x - 18, y, x - 4, y, c);
        it.line(x + 4, y, x + 18, y, c);
        it.line(x, y - 18, x, y - 4, c);
        it.line(x, y + 4, x, y + 18, c);
        it.filled_circle(x, y, 2, c);
      };

      auto get_detail_title = [&]() -> std::string {
        switch (id(detail_source)) {
          case 0: return "BBC";
          case 1: return "DC";
          case 2: return "Loudoun";
          case 3: return "Word of the Day";
          case 4: return "Quote of the Hour";
          default: return "Detail";
        }
      };

      auto get_detail_body = [&]() -> std::string {
        if (id(detail_source) == 0) {
          if (id(feed_bbc_title).has_state() && !id(feed_bbc_title).state.empty()) return id(feed_bbc_title).state;
          if (id(feed_bbc_message).has_state() && !id(feed_bbc_message).state.empty()) return id(feed_bbc_message).state;
          if (id(feed_bbc_event_type).has_state() && !id(feed_bbc_event_type).state.empty()) return id(feed_bbc_event_type).state;
          if (id(feed_bbc_state).has_state()) return id(feed_bbc_state).state;
        } else if (id(detail_source) == 1) {
          if (id(feed_dc_title).has_state() && !id(feed_dc_title).state.empty()) return id(feed_dc_title).state;
          if (id(feed_dc_message).has_state() && !id(feed_dc_message).state.empty()) return id(feed_dc_message).state;
          if (id(feed_dc_event_type).has_state() && !id(feed_dc_event_type).state.empty()) return id(feed_dc_event_type).state;
          if (id(feed_dc_state).has_state()) return id(feed_dc_state).state;
        } else if (id(detail_source) == 2) {
          if (id(feed_loudoun_title).has_state() && !id(feed_loudoun_title).state.empty()) return id(feed_loudoun_title).state;
          if (id(feed_loudoun_message).has_state() && !id(feed_loudoun_message).state.empty()) return id(feed_loudoun_message).state;
          if (id(feed_loudoun_event_type).has_state() && !id(feed_loudoun_event_type).state.empty()) return id(feed_loudoun_event_type).state;
          if (id(feed_loudoun_state).has_state()) return id(feed_loudoun_state).state;
        } else if (id(detail_source) == 3) {
          if (id(word_of_day).has_state()) return id(word_of_day).state;
        } else if (id(detail_source) == 4) {
          if (id(quote_of_hour).has_state()) return id(quote_of_hour).state;
        }
        return std::string("No readable content available.");
      };

      auto feed_preview = [&](int source) -> std::string {
        auto compact = [&](const std::string &s) -> std::string {
          if (s.empty()) return std::string("-");
          if (s.size() <= 16) return s;
          return s.substr(0, 15) + ".";
        };

        if (source == 0) {
          if (id(feed_bbc_title).has_state() && !id(feed_bbc_title).state.empty()) return compact(id(feed_bbc_title).state);
          if (id(feed_bbc_message).has_state() && !id(feed_bbc_message).state.empty()) return compact(id(feed_bbc_message).state);
          if (id(feed_bbc_state).has_state()) return compact(id(feed_bbc_state).state);
        } else if (source == 1) {
          if (id(feed_dc_title).has_state() && !id(feed_dc_title).state.empty()) return compact(id(feed_dc_title).state);
          if (id(feed_dc_message).has_state() && !id(feed_dc_message).state.empty()) return compact(id(feed_dc_message).state);
          if (id(feed_dc_state).has_state()) return compact(id(feed_dc_state).state);
        } else if (source == 2) {
          if (id(feed_loudoun_title).has_state() && !id(feed_loudoun_title).state.empty()) return compact(id(feed_loudoun_title).state);
          if (id(feed_loudoun_message).has_state() && !id(feed_loudoun_message).state.empty()) return compact(id(feed_loudoun_message).state);
          if (id(feed_loudoun_state).has_state()) return compact(id(feed_loudoun_state).state);
        } else if (source == 3) {
          if (id(word_of_day).has_state()) return compact(id(word_of_day).state);
        } else if (source == 4) {
          if (id(quote_of_hour).has_state()) return compact(id(quote_of_hour).state);
        }
        return std::string("-");
      };

      auto fmt_num = [&](float v, const char *fmt, char *out, int out_len) {
        if (v != v) {
          snprintf(out, out_len, "--");
        } else {
          snprintf(out, out_len, fmt, v);
        }
      };

      auto theme_name = [&]() -> const char * {
        if (id(theme_index) == 1) return "Ocean";
        if (id(theme_index) == 2) return "Amber";
        return "Graphite";
      };

      auto preset_name = [&]() -> const char * {
        switch (id(light_preset_index)) {
          case 0: return "Warm";
          case 1: return "Cool";
          case 2: return "Relax";
          case 3: return "Focus";
          default: return "Party";
        }
      };

      auto draw_wrapped = [&](const std::string &text, int x, int y, int max_chars, int max_lines) {
        std::string line;
        std::string word;
        int line_no = 0;

        auto flush_line = [&](bool force) {
          if (!line.empty() && line_no < max_lines) {
            it.printf(x, y + (line_no * 16), id(font_small), c_text(), TextAlign::TOP_LEFT, "%s", line.c_str());
            line.clear();
            line_no++;
          } else if (force && line_no < max_lines) {
            it.printf(x, y + (line_no * 16), id(font_small), c_text(), TextAlign::TOP_LEFT, " ");
            line_no++;
          }
        };

        auto push_word = [&]() {
          if (word.empty()) return;
          if (line.empty()) {
            line = word;
          } else if ((int)(line.size() + 1 + word.size()) <= max_chars) {
            line += " " + word;
          } else {
            flush_line(false);
            line = word;
          }
          word.clear();
        };

        for (size_t i = 0; i < text.size() && line_no < max_lines; i++) {
          char ch = text[i];
          if (ch == '\n' || ch == '\r') {
            push_word();
            flush_line(false);
          } else if (ch == ' ') {
            push_word();
          } else {
            word.push_back(ch);
            if ((int)word.size() > max_chars) {
              if (line.empty()) {
                line = word.substr(0, max_chars);
                word.erase(0, max_chars);
                flush_line(false);
              }
            }
          }
        }
        push_word();
        if (!line.empty() && line_no < max_lines) {
          it.printf(x, y + (line_no * 16), id(font_small), c_text(), TextAlign::TOP_LEFT, "%s", line.c_str());
        }
      };

      auto page_title = [&]() -> const char * {
        if (id(page_index) == 0) return "Home";
        if (id(page_index) == 1) return "Lights";
        if (id(page_index) == 2) return "Weather";
        if (id(page_index) == 3) return "Reader";
        if (id(page_index) == 4) return "Settings";
        return "Theme";
      };

      if (id(screensaver_active) && !id(touch_cal_mode)) {
        it.fill(c_bg());
        it.printf(160, 88, id(font_title), c_text(), TextAlign::TOP_CENTER, "Sleeping");
        it.printf(160, 114, id(font_small), c_text_dim(), TextAlign::TOP_CENTER, "Touch / key / trackball to wake");
        it.printf(160, 145, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER,
                  "Batt %.2fV  %d%%",
                  id(battery_voltage_raw).state,
                  (int) id(battery_percent).state);
        return;
      }

      if (id(touch_cal_mode)) {
        const int gx[3] = {48, 160, 272};
        const int gy[3] = {44, 120, 196};

        int idx = id(touch_cal_step);
        int col = idx % 3;
        int row = idx / 3;

        const char *labels[9] = {
          "TOP LEFT", "TOP CENTER", "TOP RIGHT",
          "MID LEFT", "CENTER", "MID RIGHT",
          "BOT LEFT", "BOT CENTER", "BOT RIGHT"
        };

        it.fill(c_bg());
        it.printf(160, 8, id(font_title), c_text(), TextAlign::TOP_CENTER, "TOUCH CAL 9-POINT");
        it.rectangle(12, 34, 296, 1, c_border());
        it.printf(160, 40, id(font_small), c_text_dim(), TextAlign::TOP_CENTER, "Tap each target center");

        for (int r = 0; r < 3; r++) {
          for (int c = 0; c < 3; c++) {
            draw_crosshair(gx[c], gy[r], c_border());
          }
        }

        draw_crosshair(gx[col], gy[row], c_good());
        it.printf(160, 218, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER, "%s", labels[idx]);
        return;
      }

      if (id(detail_mode)) {
        it.fill(c_bg());
        it.printf(160, 10, id(font_title), c_text(), TextAlign::TOP_CENTER, "%s", get_detail_title().c_str());
        it.rectangle(12, 36, 296, 1, c_border());
        draw_wrapped(get_detail_body(), 14, 46, 38, 10);
        it.rectangle(12, 224, 296, 1, c_border());
        it.printf(160, 228, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER, "Click / Enter / touch to close");
        return;
      }

      it.fill(c_bg());
      it.filled_rectangle(0, 0, 320, 34, c_panel());
      it.rectangle(0, 0, 320, 34, c_border());

      if (id(page_index) != 0) {
        it.filled_rectangle(6, 6, 50, 22, c_panel_sel());
        it.rectangle(6, 6, 50, 22, c_good());
        it.printf(31, 11, id(font_micro), c_text(), TextAlign::TOP_CENTER, "HOME");
      }

      it.printf(160, 8, id(font_title), c_text(), TextAlign::TOP_CENTER, "%s", page_title());
      it.printf(312, 10, id(font_micro), c_text_dim(), TextAlign::TOP_RIGHT, "%s", theme_name());

      const int w = 92;
      const int h = 72;
      const int x1 = 12;
      const int x2 = 114;
      const int x3 = 216;
      const int y1 = 42;
      const int y2 = 126;

      if (id(page_index) == 0) {
        char temp_buf[16];
        fmt_num(id(wx_temp).state, "%.1f", temp_buf, sizeof(temp_buf));
        draw_tile(x1, y1, w, h, "Lights",   id(focus_index) == 0, light_name(id(selected_light)));
        draw_tile(x2, y1, w, h, "Weather",  id(focus_index) == 1, temp_buf);
        draw_tile(x3, y1, w, h, "Reader",   id(focus_index) == 2, "feeds");
        draw_tile(x1, y2, w, h, "Settings", id(focus_index) == 3, "device");
        draw_tile(x2, y2, w, h, "Themes",   id(focus_index) == 4, theme_name());
        draw_tile(x3, y2, w, h, "Sleep",    id(focus_index) == 5, "screen");
        it.printf(160, 208, id(font_small), c_text_dim(), TextAlign::TOP_CENTER,
                  "Main menu only. Subpages stay uncluttered.");
      } else if (id(page_index) == 1) {
        char light_buf[40];
        snprintf(light_buf, sizeof(light_buf), "%s (%s)", light_name(id(selected_light)), light_state_text(id(selected_light)));
        it.printf(160, 36, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER, "%s", light_buf);
        draw_tile(x1, y1, w, h, "Prev",    id(focus_index) == 0, "Light");
        draw_tile(x2, y1, w, h, "Next",    id(focus_index) == 1, "Light");
        draw_tile(x3, y1, w, h, "Toggle",  id(focus_index) == 2, light_state_text(id(selected_light)));
        draw_tile(x1, y2, w, h, "Dim",     id(focus_index) == 3, "-20%");
        draw_tile(x2, y2, w, h, "Bright",  id(focus_index) == 4, "+20%");
        draw_tile(x3, y2, w, h, "Preset",  id(focus_index) == 5, preset_name());
      } else if (id(page_index) == 2) {
        char temp_buf[16];
        char feels_buf[16];
        char hum_buf[20];
        char wind_buf[20];
        char uv_buf[20];
        char cloud_buf[20];
        char press_buf[20];
        char vis_buf[20];
        fmt_num(id(wx_temp).state, "%.1f", temp_buf, sizeof(temp_buf));
        if (id(wx_feels).state != id(wx_feels).state) snprintf(feels_buf, sizeof(feels_buf), "Feels --");
        else snprintf(feels_buf, sizeof(feels_buf), "Feels %.1f", id(wx_feels).state);
        if (id(wx_humidity).state != id(wx_humidity).state) snprintf(hum_buf, sizeof(hum_buf), "--");
        else snprintf(hum_buf, sizeof(hum_buf), "%.0f%%", id(wx_humidity).state);
        fmt_num(id(wx_wind_speed).state, "%.0f", wind_buf, sizeof(wind_buf));
        fmt_num(id(wx_uv).state, "%.1f", uv_buf, sizeof(uv_buf));
        if (id(wx_clouds).state != id(wx_clouds).state) snprintf(cloud_buf, sizeof(cloud_buf), "--");
        else snprintf(cloud_buf, sizeof(cloud_buf), "%.0f%%", id(wx_clouds).state);
        fmt_num(id(wx_pressure).state, "%.0f", press_buf, sizeof(press_buf));
        fmt_num(id(wx_visibility).state, "%.0f", vis_buf, sizeof(vis_buf));

        const char *cond = id(wx_weather).has_state() ? id(wx_weather).state.c_str() :
                           (id(wx_condition).has_state() ? id(wx_condition).state.c_str() : "-");

        it.filled_rectangle(12, 42, 296, 72, c_panel());
        it.rectangle(12, 42, 296, 72, c_border());
        it.printf(24, 52, id(font_title), c_text(), TextAlign::TOP_LEFT, "%s", temp_buf);
        it.printf(24, 77, id(font_small), c_text_dim(), TextAlign::TOP_LEFT, "%s", cond);
        it.printf(24, 94, id(font_micro), c_text_dim(), TextAlign::TOP_LEFT, "%s", feels_buf);

        const int mw = 94;
        const int mh = 44;
        const int mx1 = 12;
        const int mx2 = 113;
        const int mx3 = 214;
        const int my1 = 124;
        const int my2 = 174;
        auto metric = [&](int x, int y, const char *label, const char *value) {
          it.filled_rectangle(x, y, mw, mh, c_panel());
          it.rectangle(x, y, mw, mh, c_border());
          it.printf(x + 8, y + 6, id(font_micro), c_text_dim(), TextAlign::TOP_LEFT, "%s", label);
          it.printf(x + 8, y + 21, id(font_small), c_text(), TextAlign::TOP_LEFT, "%s", value);
        };
        metric(mx1, my1, "Humidity", hum_buf);
        metric(mx2, my1, "Wind", wind_buf);
        metric(mx3, my1, "UV", uv_buf);
        metric(mx1, my2, "Clouds", cloud_buf);
        metric(mx2, my2, "Pressure", press_buf);
        metric(mx3, my2, "Visibility", vis_buf);
      } else if (id(page_index) == 3) {
        auto p0 = feed_preview(0);
        auto p1 = feed_preview(1);
        auto p2 = feed_preview(2);
        auto p3 = feed_preview(3);
        auto p4 = feed_preview(4);
        draw_tile(x1, y1, w, h, "BBC",     id(focus_index) == 0, p0.c_str());
        draw_tile(x2, y1, w, h, "DC",      id(focus_index) == 1, p1.c_str());
        draw_tile(x3, y1, w, h, "Loudoun", id(focus_index) == 2, p2.c_str());
        draw_tile(x1, y2, w, h, "Word",    id(focus_index) == 3, p3.c_str());
        draw_tile(x2, y2, w, h, "Quote",   id(focus_index) == 4, p4.c_str());
        draw_tile(x3, y2, w, h, "Quote+",  id(focus_index) == 5, p4.c_str());
      } else if (id(page_index) == 4) {
        char saver_buf[20];
        snprintf(saver_buf, sizeof(saver_buf), "%ds", id(screensaver_timeout_s));
        draw_tile(x1, y1, w, h, "Saver-",    id(focus_index) == 0, saver_buf);
        draw_tile(x2, y1, w, h, "Saver+",    id(focus_index) == 1, saver_buf);
        draw_tile(x3, y1, w, h, "WakeTouch", id(focus_index) == 2, id(wake_on_touch) ? "ON" : "OFF");
        draw_tile(x1, y2, w, h, "WakeKeys",  id(focus_index) == 3, id(wake_on_keyboard) ? "ON" : "OFF");
        draw_tile(x2, y2, w, h, "WakeBall",  id(focus_index) == 4, id(wake_on_trackball) ? "ON" : "OFF");
        draw_tile(x3, y2, w, h, "Debug",     id(focus_index) == 5, id(touch_debug) ? "ON" : "OFF");
      } else {
        char bl_buf[20];
        snprintf(bl_buf, sizeof(bl_buf), "%d%%", id(backlight_percent));
        draw_tile(x1, y1, w, h, "Theme-",   id(focus_index) == 0, theme_name());
        draw_tile(x2, y1, w, h, "Theme+",   id(focus_index) == 1, theme_name());
        draw_tile(x3, y1, w, h, "Disp-",    id(focus_index) == 2, bl_buf);
        draw_tile(x1, y2, w, h, "Disp+",    id(focus_index) == 3, bl_buf);
        draw_tile(x2, y2, w, h, "TouchCal", id(focus_index) == 4, "start");
        draw_tile(x3, y2, w, h, "Debug",    id(focus_index) == 5, id(touch_debug) ? "ON" : "OFF");
        it.printf(160, 208, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER, "Theme + display controls");
      }

      it.rectangle(0, 223, 320, 1, c_border());
      it.printf(8, 226, id(font_micro), c_text_dim(), TextAlign::TOP_LEFT, "Pg:%d", id(page_index) + 1);
      it.printf(160, 226, id(font_micro), c_text_dim(), TextAlign::TOP_CENTER, "Sel:%s", light_name(id(selected_light)));
      it.printf(312, 226, id(font_micro), c_text_dim(), TextAlign::TOP_RIGHT, "BL:%d%%", id(backlight_percent));

      if (id(touch_debug) && id(touch_active)) {
        it.filled_circle(id(touch_x_last), id(touch_y_last), 5, c_good());
      }
